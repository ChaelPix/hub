==========
Navigation
==========

La navigation est l'un des points les plus importants de la robotique mobile. Elle comprend de
nombreux principes comme le calcul de trajectoire, le suivi de trajectoire, etc.

Ici sera expliqué le projet de navigation sur ROS2, Navigation2, grâce à notre expérience dessus. Ce
projet est un stack de navigation (i.e. un regroupement de packages / librairies) dont voici la
`documentation <https://navigation.ros.org/>`__.

D'autres projets existent, comme par exemple MoveIt, mais nous n'avons pas encore d'expérience
dessus. Vous pouvez retrouver plus d'informations ainsi que la documentation de ce projet
`ici <https://moveit.ros.org/>`__.

.. contents:: Sommaire
    :depth: 4

Concepts généraux
#################

Navigation2 repose sur plusieurs concepts, qui ne sont pas forcément propres à ce projet mais
communs à d'autres projets de navigation.

"Costmap"
*********

Une map est souvent initialement une image en 2D. Pour les algorithmes ayant besoin d'une map pour
travailler, il faut à partir de cette map créer une représentation qui peut être dynamique et
évoluer en fonction de l'environnement du robot.

Ainsi, les maps sont représentées par des costmaps, c'est-à-dire des "maps de coût". Cela permet de
connaître et représenter des informations présentes dans l'environnement du robot.

Premièrement, une map est discrétisée en cellules à une certaine échelle. Par exemple, pour une map
qui fait 2m x 2m, une discrétisation à une échelle de 1mm créera une costmap de 2000 * 2000
cellules. Ensuite, chaque cellule possède une valeur qui représente la dangerosité d'avoir un robot
placé dans cette cellule. Par exemple, dans Navigation2, une cellule peut avoir une valeur de 0 à
255, 0 étant un endroit libre, 255 étant une cellule léthale, c'est-à-dire que le robot ne peut pas
être placé dans cet endroit (par exemple un mur). Les cellules peuvent avoir toutes les valeurs
possibles entre 0 et 255.

AJOUTER IMAGE

Inflation
*********

L'inflation est un concept totalement lié aux costmaps. C'est le fait qu'une cellule considérée
comme occupée (i.e. léthale : mur, obstacle, etc.) impacte, en augmantant, le coût des cellules
voisines. Cela permet de représenter qu'il est possible au robot d'être proche d'un mur mais que
cela a un coût fort et donc une certaine dangerosité.

L'impact qu'a une cellule léthale sur ses voisines peut-être définie de plein de façons
différentes : décroissance linéaire, exponentielle décroissante, etc.

AJOUTER IMAGE

"Planner"
*********

Un "planner" (planificateur en français) est un algorithme de planification de chemin. Il prend un
point de départ et un point d'arrivée et trouve un chemin entre les deux. Il existe de nombreux
algorithmes différents pour correspondre à tous types de robots mais aussi de comportements : robot
ackermann (i.e. voiture), robot holonomique (peut tourner sur lui-même), capacité de reculer,
caractéristiques des courbes, etc.

Pour choisir le chemin, un planner utilise des costmaps : en effet, le planner va utiliser le coût
des cellules pour savoir où il peut passer, les zones à éviter, les passages à favoriser, etc.

AJOUTER IMAGE

"Controller"
************

Un controller (contrôleur en français) est un algorithme de suivi de chemin. Il prend en entrée un
chemin à suivre (produit par un planner) et génère des commandes de vélocité que le robot va suivre.
Il existe de nombreux algorithmes différents qui sont paramètrables mais implémentent des
comportments très différents les uns des autres pour s'adpater aux capacités physiques des robots (
ackermann, holonomique).


Concepts Navigation2
####################

Certains concepts sont propes au stack Navigation2 et utilisent les concepts généraux mentionnés
ci-dessus.

"Lifecyle Node"
***************

ROS2 natif
==========

Les Lifecycle Nodes sont une fonctionnalité de ROS2. Ce sont des nodes classiques mais qui ont un
état interne en plus afin de suivre où elles en sont dans leur éxécution. Les états possibles sont
les suivants :

- Unconfigured : la node vient d'être créée.
- Inactive : la node est configurée (elle a récupéré ses paramètres, démarré ses subscribers et
  publishers, etc.), elle est prête à fonctionner correctement.
- Active : la node est en cours de fonctionnement (elle échange sur ses topics, etc.).
- Finalized : la node a fini de fonctionner, elle a subi une erreur ou il lui a été indiquée de
  s'arrêter.

Des transitions existent entre tous ces états et il est possible d'implémenter des méthodes dans la
node qui seront éxécutées lors de la transition pour faire ce que votre node a à faire avant
d'arriver dans un état.

L'intérêt de ces nodes est d'avoir un bien plus grand contrôle sur ce qu'elles font. Les différentes
phases de transition permettent d'isoler du code et de contrôler son éxecution. Les états offrent un
plus grand contrôle sur ce qu'il se passe et ce qu'il s'est passé dans la node (erreur par exemple).

Navigation2
===========

Le stack Navigation2 implémente une extension des lifefycle nodes qui simplifie leur utilisation
mais ne rajoute pas spécialement de réelle fonctionnalités.

Exemple
=======

Voici un exemple de méthode implémentée dans la node qui est éxécutée lors d'une transition :

.. code-block:: cpp

    // Méthode éxécutée lorsque que la node va se configurer (passe de l'état Unconfigured à Inactive)
    nav2_util::CallbackReturn MyNodeClass::on_configure(const rclcpp_lifecycle::State & /*state*/)
    {
        // Pour que la node soit considérée comme Inactive (c'est-à-dire configurée et prête à être
        // utilisé) on démarre nos publishers et subscribers
        my_pub_ = create_publisher<std_msgs::msg::Float32>("my_topic", 10);

        my_sub_ = create_subscription<std_msgs::msg::Int32>("my_other_topic", 10, std::bind(&MyNodeClass::call_back, this, std::placeholders::_1));
    }

"Lifecycle Manager"
*******************

Node implémenté par le stack Navigation2. Elle prend en configuration des noms de lyfecycle nodes et
peut les faire transitionner et connaître leur état. 

TFs
***

Dans le stack Navigation2 (et plus généralement dans ROS, voir le
`REP-105 <https://www.ros.org/reps/rep-0105.html>`__), il y a une convention pour le nom des frames
et leur lien. Par convention la frame originelle se nomme *map* et est l'origine de la map de la
navigation.

Ensuite, il existe une première tf entre *map* et la frame *odom*. Cette frame est l'origine du
robot et c'est par rapport à celle-ci que le robot se déplace.

Il existe ensuite une tf entre *odom* et *base_link* qui représente très souvent la valeur de
l'odométrie du robot. C'est dans la frame *base_link* que tous les élements du robot sont définis.
Cela peut-être les élements fixes (capteurs, etc.) ou bien les élements mobiles (roues).

Il existe aussi une tf entre *base_link* et *base_footprint*. Cette frame est la projection de
*base_link* sur le sol. Elle n'est pas forcément nécessaire pour le stack Navigation2.

AJOUTER IMAGE

"Server"
********

Dans le stack Navigation2, certaines nodes sont qualifiées de "servers". (`controller_server`,
`planner_server`, etc). La notion peut sembler peu claire au premier abord. Le terme "server" est
ici employé au sens des serveurs d'action ROS. C'est donc une node qui implémente le code qui sera
exécuté lors de l'appel d'une action.

Dans le stack, chaque node considérée comme un serveur englobe une système (le controller pour le
`controller_server` par exemple) et implémente des actions pour que le reste du stack puisse
utiliser son système. Le système englobé par chaque node est configurable (controller configurable
pour le `controller_server`, planner configurable pour le `planner_server`, etc.). Elle permet ainsi
d'asbtraire le système pour le reste du stack et le stack pour le système. Par exemple, le
controller peut être changé dans la config, le `controller_server` charge dynamiquement le
controller au lancement mais pour le reste du stack, rien n'a changé : les actions implémentées par
le `controller_server` sont toujours présentes et c'est ce dernier qui se charge de rediriger
l'appel des actions vers le controller.

En plus du système principale qui est configurable, un serveur est généralement configurable par des
plugins prévus par Navigation2 qui permettent de lui rajouter des fonctionnalités.

Les différents serveurs existants dans le stack sont :

- `controller_server` : implémente les controllers
- `planner_server` : implémente les planners
- `map_server` : charge et enregistre les maps
- `behavior_server` (anciennement recoveries_server): implémente des "behaviors" (actions pour les
  recoveries et autre)
- `smoother_server` : implémente des smoothers pour lisser les chemins générés par le planner

"Layers"
********

Dans le Navigation2, les layers sont des plugins qui se rajoutent sur une costmap et permettent de
prendre en compte de nouveaux éléments pour mettre à jour les coûts dans la costmap. Par exemple,
pour prendre en compte l'inflation des obstacles et mur sur une costmap, il faut que le plugin
`inflation_layer` soit présent. Il existe de nombreuses sources qui peuvent affecter les costmaps,
il y a donc tout autant de layers et donc de plugins :

- `voxel_layer` : Crée une costmap 3D (voxel) à partir d'informations de profondeurs et de scans
  laser
- `range_layer` : Crée des obstacles à partir de mesure de distance (capteurs ultrason, infrarouge)
- `static_layer` : Charge une map
- `inflation_layer` : Crée une zone autour des obstacles de la map
- `obstacle_layer` : Crée des obstacles à partir d'un scan laser
- `spatio_temporal_voxel_layer` : Crée une costmap 3D (voxel) à partir de scans laser, les voxels
  disparaissent à partir de paramètres temporels et spatiaux
- `non_persisten_voxel_layer` : Crée une costmap 3D (voxel) non-persistente (qui se reset à chaque
  scan) à partir de scans laser
- `denoise_layer` : Filtre les obstacles isolés ou les petits groupes d'obstacles induits par le
  bruit

"Global Costmap"
****************

La global costmap est un concept très important de Navigation2. C'est une costamp de la map entière
qui est utilisée par le **planner** pour générer un chemin. Comme expliqué juste au-dessus, elle
peut avoir différents layers.

Elle possède une frame en tant que repère, on prend donc classiquement la frame *map*.

"Local Costmap"
***************

La local costmap est un concept aussi très important de Navigation2. C'est la costmap utilisée par
le **controller** pour déplacer le robot, elle est donc relative au robot et se place classiquement
dans la frame *odom*. Elle est plus petite que la frame et est donc glissante dans la global
costmap.

"Behavior Tree"
***************

Vous pouvez avoir plus d'information sur le principe de Behavior Tree sur cette page de la
:doc:`documentation </ros/behavior_tree>`.

Le stack Navigation2 implémente la librarie `BehaviorTree.CPP <https://www.behaviortree.dev/>`__
pour ROS2. Cette implémentation permet d'intégrer des actions et services ROS2 dans les behavior
trees. De plus, l'implémentation ajoute des nodes (de behavior trees, pas de ROS) utiles à la
navigation.

De plus, le stack implémente une node `BT Navigator` qui possède deux actions, `NavigateToPose`
and `NavigateThroughPoses`. Ces actions, lorsqu'elles sont appelées, utilisent un behavior tree
chargé par `BT Navigator` pour implémenter le comportement voulu.

AMCL
****

Le stack implémente un algorithme de localisation utilisant un LiDAR : AMCL (Adaptive Monte Carlo
Localization). C'est un algorithme probabiliste de localisation utilisant un système de filtre à
particules qui va converger vers la position du robot. Il utilise au moins un laser scan et peut
aussi prendre en compte l'odométrie pour avoir un résultat encore plus précis. Il est hautement
configurable.

Nodes
#####

Avec tous les concepts évoqués précédemment, le stack implémente de nombreuses nodes pour son
fonctionnement global.

Dans le package `nav2_bringup`, un launch file nommé `bringup_launch.py` permet de lancer
l'entièreté du stack. Ce launch est décomposé en 3 autres launchs 

Voici la liste des nodes qui constitue le stack :

*amcl*
******

Une node amcl est disponible de base et implémente l'algorithme d'AMCL. N'ayant pas de LiDAR pour
les internationales 2022, nous n'avons que très peu expérimenté avec cette node.

*controller_server*
*******************

Le controller_server est, comme évoqué précédemment, la node qui implémente l'algorithme de
controller. Elle implémente en plus, deux fonctionnalités : une pour connaître la progression du
robot et une autre pour vérifier si l'objectif est atteint.

Vous pouvez trouver plus d'infos sur cette node et ses paramètres sur la pagé dédiée de la
`documentation <https://navigation.ros.org/configuration/packages/configuring-controller-server.html>`__.

Paramètres
==========

Voici des recommandations à propos de certains paramètres de cette node. La liste **n'est pas
exhaustive**.

**use_sim_time**
    *True* pour utilisé un temps simulé (par Gazebo), *False* pour utiliser le temps réel.

**odom_topic**
    Topic sur lequel récupérer la vitesse instantané du robot.

**controller_frequency**
    Fréquence de calcul du controller, 20 est un peu lourd pour un Rasperry Pi avec l'ensemble du
    stack qui tourne, 10 est un peu plus approprié.

**min_x_velocity_threshold**
    Valeur minimum de vitesse en x (avance du robot) afin que le controller la prenne en compte, une
    valeur en-dessous sera considérée comme 0.0. La valeur de base est de 0.0001 m/s, on l'avait
    mise à 0.001 m/s car c'était la résolution de la map.

**min_y_velocity_threshold**
    Valeur minimum de vitesse en y afin que le controller la prenne en compte, une valeu en-dessous
    sera considérée comme 0.0. La valeur de base est de 0.0001 m/s, on l'avait mise à 0.001 m/s car
    c'était la résolution de la map. C'est un paramètre à définir absolument quand le robot est
    **holonomique**.

**min_theta_velocity_threshold**
    Valeur minimum de vitesse de rotation afin que le controller la prenne en compte, une valeur
    en-dessous sera considérée comme 0.0.

**failure_tolerance**
    Temps de calcul avant que l'action de calculer une commande de vélocité soit considérée en
    erreur. Le mettre à -1 définit le temps comme infini, le mettre à 0 le désactive (quelle est la
    différence entre les deux ?).

**progress_checker**
    Plugin qui calcule la progression du robot vers son objectif. Les paramètres du plugin sont
    souvent des valeurs minimums afin de considérer que le robot est en progression vers son
    objectif. Ce progrès est potentiellement utilisé par certains controllers.

**general_goal_checker**
    Plugin qui estime si le robot a atteint son objectif. Les paramètres du plugin sont généralement
    des intervalles (de distance et d'angle) : si la distance (position et angle) entre le robot et
    son objectif est dans cette intervalle, l'objectif est considéré comme atteint.

**controller_plugins**
    Paramètre où tous les paramètres du controller sont définis (dont celui utilisé avec *plugin*),
    voir l'exemple en-dessous pour mieux comprendre. De base, le nom de ce paramètre est
    "FollowPath".

Voici un exemple de configuration (celle utilisée sur le robot Flo) :

.. code-block:: yaml

    controller_server:
        ros__parameters:
            use_sim_time: False
            controller_frequency: 10.0
            min_x_velocity_threshold: 0.001
            min_y_velocity_threshold: 5.0 # Holonomic Parameter
            min_theta_velocity_threshold: 0.001
            # Maximum time to allow to compute velocity command
            # 0 to disable
            # -1 to make it infinite (what's the difference with disabled?)
            failure_tolerance: 1.0
            progress_checker_plugin: "progress_checker"
            goal_checker_plugins: ["general_goal_checker"]
            controller_plugins: ["FollowPath"]
            odom_topic: "/odometry/filtered"

            # Progress checker parameters
            progress_checker:
                plugin: "nav2_controller::SimpleProgressChecker"
                required_movement_radius: 0.5

            # Goal checker parameters
            general_goal_checker:
                stateful: True
                plugin: "nav2_controller::SimpleGoalChecker"
                xy_goal_tolerance: 0.05
                yaw_goal_tolerance: 0.03

            # CustomRegulatedPurePursuitController, modified RegulatedPurePursuitController build by
            # ourself, not native to nav2
            FollowPath:
                plugin: "nav2_regulated_pure_pursuit_controller::CustomRegulatedPurePursuitController"
                desired_linear_vel: 0.30
                max_linear_accel: 1.0
                lookahead_dist: 0.30
                min_lookahead_dist: 0.3
                max_lookahead_dist: 0.35
                lookahead_time: 1.5
                rotate_to_heading_angular_vel: 0.55
                # Higher values seem to limit the "Control loop missed its desired rate" for some reasons
                transform_tolerance: 1.0
                use_velocity_scaled_lookahead_dist: false
                min_approach_linear_velocity: 0.15
                use_approach_linear_velocity_scaling: true
                max_allowed_time_to_collision: 1.0
                #max_allowed_time_to_collision_up_to_carrot: 1.0
                use_regulated_linear_velocity_scaling: false
                use_cost_regulated_linear_velocity_scaling: false
                #regulated_linear_scaling_min_radius: 0.6
                #regulated_linear_scaling_min_speed: 0.05
                use_rotate_to_heading: true
                allow_reversing: false
                rotate_to_heading_min_angle: 0.6
                max_angular_accel: 10.0
                #max_robot_pose_search_dist: 10.0
                use_interpolation: false

*planner_server*
****************

Le planner_server est la node qui implémente l'algorithme de planner.

Vous pouvez trouver plus d'infos sur cette node et ses paramètres sur la pagé dédiée de la
`documentation <https://navigation.ros.org/configuration/packages/configuring-planner-server.html>`__.

Paramètres
==========

Voici des recommandations à propos de certains paramètres de cette node. La liste **n'est pas
exhaustive**.

**use_sim_time**
    *True* pour utilisé un temps simulé (par Gazebo), *False* pour utiliser le temps réel.

**expected_planner_frequency**
    Fréquence voulue du planner. C'est uniquement indicatif et ne provoquera qu'un log si la
    fréquence n'est pas suffisante.

**planner_plugins**
    Paramètre où tous les paramètres du planner sont définis (dont celui utilisé avec *plugin*),
    voir l'exemple en-dessous pour mieux comprendre. De base, le nom de ce paramètre est
    "GridBased".

Voici un exemple de configuration (celle utilisée sur le robot Flo) :

.. code-block:: yaml

    planner_server:
        ros__parameters:
            expected_planner_frequency: 1.0  # Does not have any impact, just log if planner is too slow
            use_sim_time: False
            planner_plugins: ["GridBased"]
            GridBased:
                plugin: "nav2_navfn_planner/NavfnPlanner"
                tolerance: 0.5
                use_astar: false
                allow_unknown: true

*gloabal_costmap*
*****************

**always_send_full_costmap**
    *True* pour envoyer la costmap entière, *False* pour envoyer uniquement les modifications de la
    costmap. Mettre à *False* réduit probablement la consommation de ressources.
