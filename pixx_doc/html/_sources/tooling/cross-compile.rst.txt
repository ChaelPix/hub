============================
Cross-compilation via Docker
============================

Nous avons développé un outil qui permet de cross-compiler.
Imaginons que nous voulons compiler un code pour RPi, mais que nous ne voulons pas attendre une
éternité parce que ça compile trop lentement sur notre petite RPi.

Aussi, la RPi n'a pas de RTC (real-time clock) ce qui, si elle n'est pas connectée à internet (comme
en compétition par exemple), ne lui permet pas de garder l'heure à jour. Le problème de cela est
que, quand vous allez changer le code, il se pourrait que la RPi se réinitialise à une date
antérieure à votre dernière compilation. Ce qui aura pour effet de laisser croire au compilateur de
votre RPi que le programme est déjà à jour, ce qui n'est pas forcément le cas.

En bref la cross-compilation va nous résoudre deux gros problèmes en compétition :

- le temps de compilation
- la date des binaires générés

Nous allons donc expliquer comment l'utiliser avec Docker dans un premier temps.

Et dans un second temps générer ou actualiser son/ses propres Docker.

.. contents:: Sommaire
  :depth: 4

Utiliser Docker pour la cross-compilation
#########################################

Installer Docker
****************

Premièrement, il faut installer Docker. Personnellement, j'utilise docker-ce par habitude.

- Soyez certain de bien désinstaller d'autres versions de Docker avant de commencer.

.. code-block:: bash

  for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done

- Ajoutez la clé officielle de Docker

.. code-block:: bash

  sudo apt-get update
  sudo apt-get install ca-certificates curl gnupg
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

- Ajoutez le repo apt

.. code-block:: bash

  echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

- Installez docker-ce

.. code-block:: bash

  sudo apt-get update
  sudo apt install docker-ce

- Verifiez que l'installation a marché

.. code-block:: bash

  sudo docker run hello-world

  # Outputs
  Unable to find image 'hello-world:latest' locally
  latest: Pulling from library/hello-world
  719385e32844: Pull complete 
  Digest: sha256:88ec0acaa3ec199d3b7eaf73588f4518c25f9d34f58ce9a0df68429c5af48e8d
  Status: Downloaded newer image for hello-world:latest

  Hello from Docker!
  This message shows that your installation appears to be working correctly.

  To generate this message, Docker took the following steps:
  1. The Docker client contacted the Docker daemon.
  2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
      (amd64)
  3. The Docker daemon created a new container from that image which runs the
      executable that produces the output you are currently reading.
  4. The Docker daemon streamed that output to the Docker client, which sent it
      to your terminal.

  To try something more ambitious, you can run an Ubuntu container with:
  $ docker run -it ubuntu bash

  Share images, automate workflows, and more with a free Docker ID:
  https://hub.docker.com/

  For more examples and ideas, visit:
  https://docs.docker.com/get-started/

- Ajoutez votre utilisateur au groupe ``docker`` pour ne pas avoir besoin de sudo. Pour que cela
  prenne effet, il est préférable de redémarrer l'ordinateur apres avoir entré la commande suivante :

.. code-block:: bash

  sudo usermod -aG docker ${USER}
  reboot # soyez sur que tout est sauvegardé sur votre ordinateur

- Après le redémarrage, vous devriez pouvoir démarrer le docker sans sudo et sans téléchargement

.. code-block:: bash

  docker run hello-world

  # Outputs
  Hello from Docker!
  This message shows that your installation appears to be working correctly.

  To generate this message, Docker took the following steps:
  1. The Docker client contacted the Docker daemon.
  2. The Docker daemon pulled the "hello-world" image from the Docker Hub.
      (amd64)
  3. The Docker daemon created a new container from that image which runs the
      executable that produces the output you are currently reading.
  4. The Docker daemon streamed that output to the Docker client, which sent it
      to your terminal.

  To try something more ambitious, you can run an Ubuntu container with:
  $ docker run -it ubuntu bash

  Share images, automate workflows, and more with a free Docker ID:
  https://hub.docker.com/

  For more examples and ideas, visit:
  https://docs.docker.com/get-started/

Sources :

- https://docs.docker.com/engine/install/ubuntu/
- https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-22-04


Utiliser le repo ros2-docker
****************************

Le lien du repo : https://github.com/Worldskills-France-Mobile-Robotics/ros2-docker

Ce repo a pour but de faciliter le démarrage et la creation d'image docker.
Il permet:

- De compiler les packets avec les mêmes dépendances que l'image RPi (si ça ne compile pas avec le
  docker, ça ne compilera pas sur la RPi)
- Simuler l'environnement du robot dans les mêmes conditions que l'image RPi
- Compiler pour une autre plateforme
- Utiliser plusieurs versions de ROS en parallèle sur un seul ordinateur

Cloner le repo
===============

Clonez le repo où vous le souhaitez:

.. code-block:: bash

  export WORKSPACE_ROOT=${HOME}/workspace
  mkdir -p ${WORKSPACE_ROOT} && cd ${WORKSPACE_ROOT}
  git clone git@github.com:Worldskills-France-Mobile-Robotics/ros2-docker.git
  cd ros2-docker

Vous allez voir l'arborescense suivante dans le dossier `ros2-docker` :

.. code-block:: bash

  .
  ├── docker
  ├── my-robot-template.bash
  ├── README.md
  ├── repos
  └── scripts

Générer le script de base
=========================

Vous avez maintenant le repo de base.
Nous allons commencer par créer un script pour notre robot.

Nous avons donc besoin d'un nom de robot et de la distribution ROS. Prenons par exemple stanley et
humble.
Par default le script prendra robot et rolling.

.. code-block:: bash

  ./scripts/generate_robot_dev.bash stanley humble

  # outputs
  stanley-dev.bash has been generated and made executable
  you can now make an alias linked to it to be able to execute from anywhere
  for example: 
    alias stanley-dev="/tmp/ros2-docker/stanley-dev.bash"

  you have a .bash_aliases the following will append to it

  echo "# thoses are variables for stanley-dev" >> ~/.bash_aliases
  echo "alias stanley-dev="/tmp/ros2-docker/stanley-dev.bash"" >> ~/.bash_aliases
  echo "export STANLEY_ROS_DISTRO=humble" >> ~/.bash_aliases
  echo "export STANLEY_ROOT=/home/flochre/workspace/robot_ws" >> ~/.bash_aliases

  Please make sure this is what you want before copying it to you bash_aliases

Nous venons de créer un fichier stanley-dev.bash qui va nous permettre d'utiliser le docker
facilement.
Le script nous conseille également de créer un alias et deux variables d'environnement et prépare
les lignes à ajouter à notre .bash_aliases.

Je ne peux que vous recommander vivement de le faire :)

Le script a une aide interne, vous pouvez la voir en utilisant le flag -h ou --help :

.. code-block:: bash

  ./stanley-dev.bash --help

  # outputs
  Welcome to the stanley-dev!
  Usage:  stanley-dev.bash [OPTIONS] COMMAND

  A simple script to use and abuse from the ros2-docker

  Common Commands:
    run           Create and run a new container from an image
    exec          Execute a command in a running container
    cross-compile Cross-compile a workspace in a dedicated container
    deploy        Deploy the cross-compile code to a host
    build         Build the image for ros2-docker
    pull          Download an image from a registry

Une fois l'alias et les variables d'environment créées, nous pouvons utiliser directement l'alias
de n'importe où sur notre ordinateur :

.. code-block:: bash

  stanley-dev --help

  # outputs
  Welcome to the stanley-dev!
  Usage:  stanley-dev.bash [OPTIONS] COMMAND

  A simple script to use and abuse from the ros2-docker

  Common Commands:
    run           Create and run a new container from an image
    exec          Execute a command in a running container
    cross-compile Cross-compile a workspace in a dedicated container
    deploy        Deploy the cross-compile code to a host
    build         Build the image for ros2-docker
    pull          Download an image from a registry

Pull docker image existante
===========================

Regardons d'abord les paramètres possibles

.. code-block:: bash

  stanley-dev pull -h
  Welcome to the stanley-dev!
  pull_docker.bash [-h|--help] [-d|--rosdistro string] -- pull the docker image based on the given parameters

  where:
      -h |--help        show this help text
      -a |--arch        set the architecture to compile (default: aarch64) other option: x86_64
      -d |--rosdistro   set the rosdistro to use (default: humble)
      -u |--user        set the docker user name (default: flochre)
      -v |--version     set the version for the Docker Tag (default: latest)

Voyez que le script vous propose les valeurs qu'il utilisera par default.
Verifiez qu'elles correspondent à ce que vous souhaitez.

Vous allez pour la première fois vouloir récuperer l'image de mon compte et je vais forcer humble
pour l'example.

.. code-block:: bash

  stanley-dev pull -d humble -u flochre

  # outputs
  Welcome to the stanley-dev!
  latest: Pulling from flochre/ros2_docker_humble
  Digest: sha256:c86b3f0556ed625b1dc18d142d3465b9b025fb13cdbe51ae07f0963a5b2e355a
  Status: Image is up to date for flochre/ros2_docker_humble:latest
  docker.io/flochre/ros2_docker_humble:latest

Nous pouvons maintenant utiliser le docker comme un autre ordinateur où faire de la
cross-compilation.

Cross-compilation
=================

Le script nous avait proposé d'utiliser des variables d'environnement, je vais donc les utiliser
maintenant pour créer un ros2 workspace à cross-compiler.

.. code-block:: bash

  export STANLEY_ROOT=$HOME/workspace/robot_ws
  mkdir -p $STANLEY_ROOT/src
  vcs-import --input repos/minimum_release_1_ws.humble.repos --recursive $STANLEY_ROOT/src

Cela va cloner tous les repos au minimum nécessaires pour démarrer le robot, dans le fichier
$STANLEY_ROOT utilisé par défaut par le script.

On peut regarder l'aide avant de l'utiliser avec --help

.. code-block:: bash

  stanley-dev cross-compile --help

  # output 
  Welcome to the stanley-dev!
  compile_docker.bash [-h|--help] [-a|--arch string] [-p|--package string] [-d|--rosdistro string] [-ws|--workspace string] -- compile inside docker based on the given parameters

  where:
      -h |--help        show this help text
      -a |--arch        set the architecture to compile (default: aarch64) other option: x86_64
      -p |--package     set the package to compile (--packages-up-to) (default: ALL)
      -d |--rosdistro   set the rosdistro to use (default: humble)
      -u |--user        set the docker user name (default: flochre)
      -v |--version     set the version for the Docker Tag (default: latest)
      -ws|--workspace   set the path of the workspace to compile (default: /home/flochre/workspace/robot_ws)

Verifiez que les valeurs par default vous conviennent. Et retirez le --help dans la commande.
Pour l'exemple, je ne souhaite pas tout compiler et je vais choisir uniquement de compiler jusqu'au
package flo_drive.

Il se peut que vous ayez un problème lors de la première compilation... Mais il se peut que cela
revienne aussi périodiquement après des mises à jour de docker par exemple. Dans ce cas : 

.. code-block:: bash

  docker run -it --rm --privileged multiarch/qemu-user-static --credential yes --persistent yes

La compilation :

.. code-block:: bash

  stanley-dev cross-compile -p flo_drive
  
  # outputs
  Welcome to the stanley-dev!
  Starting >>> flo_drive
  [Processing: flo_drive]                             
  [Processing: flo_drive]                                     
  [Processing: flo_drive]                                       
  --- stderr: flo_drive                                          
  In file included from /workspace/robot_ws/src/flo_drive/src/flo_drive/simple_holonomic_motor.cpp:1:
  /workspace/robot_ws/src/flo_drive/include/flo_drive/simple_holonomic_motor.h: In constructor ‘SimpleHolonomicMotor::SimpleHolonomicMotor(rclcpp::Node*, std::string, std::string, double, int, int, int, double, double, double, std::vector<double, std::allocator<double> >, std::vector<double, std::allocator<double> >)’:
  /workspace/robot_ws/src/flo_drive/include/flo_drive/simple_holonomic_motor.h:48:9: warning: ‘SimpleHolonomicMotor::max_motor_speed_pwm_’ will be initialized after [-Wreorder]
    48 |     int max_motor_speed_pwm_;
        |         ^~~~~~~~~~~~~~~~~~~~
  /workspace/robot_ws/src/flo_drive/include/flo_drive/simple_holonomic_motor.h:44:9: warning:   ‘int SimpleHolonomicMotor::ticks_per_round_’ [-Wreorder]
    44 |     int ticks_per_round_;
        |         ^~~~~~~~~~~~~~~~
  /workspace/robot_ws/src/flo_drive/src/flo_drive/simple_holonomic_motor.cpp:4:1: warning:   when initialized here [-Wreorder]
      4 | SimpleHolonomicMotor::SimpleHolonomicMotor(rclcpp::Node *driver_node, std::string motor_pub_name, std::string encoder_sub_name,
        | ^~~~~~~~~~~~~~~~~~~~
  ---
  Finished <<< flo_drive [1min 47s]
                            
  Summary: 1 package finished [1min 53s]
    1 package had stderr output: flo_drive
  PASS

Après la compilation :

.. code-block:: bash

  ll $STANLEY_ROOT 

  # outputs
  total 24
  drwxrwxr-x 6 flochre flochre 4096 Nov  4 17:01 ./
  drwxrwxr-x 8 flochre flochre 4096 Nov  4 16:15 ../
  drwxr-xr-x 3 flochre flochre 4096 Nov  4 17:01 build_aarch64/
  drwxr-xr-x 3 flochre flochre 4096 Nov  4 17:03 install_aarch64/
  drwxr-xr-x 3 flochre flochre 4096 Nov  4 17:01 log/
  drwxrwxr-x 7 flochre flochre 4096 Nov  4 16:18 src/

On voit que le docker a généré des dossiers de compilation classiques ROS (``log``, ``build`` et
``install``). Ici, l'architecture est spécifiée (aarch64), étant celle de la RPi, on peut les
utiliser directement dessus via le déploiement.

Félicitations, vous venez de créer vos premiers packages via cross-compilation :)

J'ai fait le test de compiler sur la RPi et sur mon ordinateur :

.. code-block:: bash

  # Cross-compiled
  Summary: 5 packages finished [3min 47s]
    3 packages had stderr output: flo_drive ros2_vmxpi ydlidar_ros2_driver

  # RPi
  # need the flag --executor sequential to compile
  Summary: 5 packages finished [11min 48s]
    3 packages had stderr output: flo_drive ros2_vmxpi ydlidar_ros2_driver


Deployement
===========

Nous allons maintenant copier nos fichiers compilés sur la RPi

.. code-block:: bash

  stanley-dev deploy -h

  # outputs
  Welcome to the stanley-dev!
  deploy_install.bash [-h|--help] [-a|--arch string] [-p|--package string] [-d|--rosdistro string] [-ws|--workspace string] -- compile inside docker based on the given parameters

  where:
      -h |--help        show this help text
      -d |--dir         the folder on the destination (default: deployement)
      -r |--host        the ssh name (Robot name) of the host of the destination (default: flochre@10.42.33.78)
      -s |--sudo        if given will copy with sudo rights (default: false)
      -ws|--workspace   set the path of the workspace to compile (default: /home/flochre/workspace/robot_ws)

Par défaut, les fichiers seront upload dans le dossier ``~/deployement``.

Si vous avez defini des hosts dans la config de votre ssh (probablement ``~/.ssh/config``), vous
pouvez directement les utiliser pour l'host (-r | --host).

.. code-block:: bash

  stanley-dev deploy -r stanley2_wifi_direct

  # output 
  Welcome to the stanley-dev!
  Deploying /home/flochre/workspace/robot_ws/install_aarch64/ to stanley2_wifi_direct:deployement ...
  PASS

Après ça, vous pouvez SSH sur la RPi et utiliser la commande suivante :

.. code-block:: bash

  . deployement/local_setup.bash

  # and use the packages as if you compiled them
  ros2 launch flo_drive ...
