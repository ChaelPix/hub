<!DOCTYPE html>
<html class="writer-html5" lang="fr" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Worflow GitHub &mdash; Documentation WSFR Mobile Robotic Team </title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../_static/css/custom.css?v=bd5b14eb" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/general.css?v=c0a7eb24" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/dark.css?v=70edf1c7" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../_static/jquery.js?v=5d32c60e"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../_static/documentation_options.js?v=d1a510d7"></script>
        <script src="../_static/doctools.js?v=888ff710"></script>
        <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../_static/copybutton.js?v=f281be69"></script>
        <script src="../_static/translations.js?v=d99ca74e"></script>
        <script src="../_static/dark_mode_js/default_dark.js?v=fd565c74"></script>
        <script src="../_static/dark_mode_js/theme_switcher.js?v=358d3910"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="next" title="ROS" href="../ros/index.html" />
    <link rel="prev" title="Repos" href="repos.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            WSFR Mobile Robotic Team
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Rechercher docs" aria-label="Rechercher docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Organisation</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="repos.html">Repos</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Worflow GitHub</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#repos">Repos</a></li>
<li class="toctree-l3"><a class="reference internal" href="#commits">Commits</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rappels">Rappels</a></li>
<li class="toctree-l4"><a class="reference internal" href="#recommandations">Recommandations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#squash"><em>Squash</em></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#branches">Branches</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">Recommandations</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ros/index.html">ROS</a></li>
<li class="toctree-l1"><a class="reference internal" href="../robots/index.html">Robots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tooling/index.html">Tooling</a></li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">Glossaire</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contribute/index.html">Contribuer</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">WSFR Mobile Robotic Team</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="index.html">Organisation</a></li>
      <li class="breadcrumb-item active">Worflow GitHub</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/orga/github.rst.txt" rel="nofollow"> Afficher la source de la page</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="worflow-github">
<h1><a class="toc-backref" href="#id9" role="doc-backlink">Worflow GitHub</a><a class="headerlink" href="#worflow-github" title="Link to this heading"></a></h1>
<p>Sur cette page, nous expliquerons notre façon de travailler avec GitHub : repos, branches, commits,
etc.</p>
<nav class="contents" id="sommaire">
<p class="topic-title">Sommaire</p>
<ul class="simple">
<li><p><a class="reference internal" href="#worflow-github" id="id9">Worflow GitHub</a></p>
<ul>
<li><p><a class="reference internal" href="#repos" id="id10">Repos</a></p></li>
<li><p><a class="reference internal" href="#commits" id="id11">Commits</a></p>
<ul>
<li><p><a class="reference internal" href="#rappels" id="id12">Rappels</a></p></li>
<li><p><a class="reference internal" href="#recommandations" id="id13">Recommandations</a></p></li>
<li><p><a class="reference internal" href="#squash" id="id14"><em>Squash</em></a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#branches" id="id15">Branches</a></p>
<ul>
<li><p><a class="reference internal" href="#id1" id="id16">Recommandations</a></p>
<ul>
<li><p><a class="reference internal" href="#notre-organisation" id="id17">Notre organisation</a></p></li>
<li><p><a class="reference internal" href="#organisation-plus-professionnelle" id="id18">Organisation plus professionnelle</a></p></li>
<li><p><a class="reference internal" href="#branche-en-retard" id="id19">Branche en retard</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="repos">
<h2><a class="toc-backref" href="#id10" role="doc-backlink">Repos</a><a class="headerlink" href="#repos" title="Link to this heading"></a></h2>
<p>En ROS, les projets fonctionnent par package. Un package ROS représente souvent une fonctionnalité,
plus ou moins importante, d’un robot. Pour l’instant, nous avons suivi la convention de créer un
repo par package ROS. De plus, nous nommons un repo avec comme préfixe, le nom du robot auquel il
est lié (« flo » par exemple pour le robot des internationales 2022).</p>
<p>Il est toujours intéressant d’avoir un readme clair sur un repo, pour indiquer le contenu du repo et
donner des instructions nécessaires (et non-intuitives) sur le repo (comment le build, etc).</p>
</section>
<section id="commits">
<h2><a class="toc-backref" href="#id11" role="doc-backlink">Commits</a><a class="headerlink" href="#commits" title="Link to this heading"></a></h2>
<p>Si vous n’avez pas besoin de rappels sur comment faire des commits via le terminal et git, vous
pouvez passer directement aux recommandations.</p>
<section id="rappels">
<h3><a class="toc-backref" href="#id12" role="doc-backlink">Rappels</a><a class="headerlink" href="#rappels" title="Link to this heading"></a></h3>
<p>git fonctionne sur des différences entre deux états d’un fichier. En effet, lorsqu’un fichier est
modifié, git n’enregistre pas le contenu complet du fichier mais uniquement la différence entre le
précédent état du fichier et l’état après modification. Cela permet un traçage dans le temps des
différentes modifications et de revenir facilement sur une modification faite dans le passé.</p>
<p>Un « commit » est un moyen d’enregistrer des modification sur un ou plusieurs fichiers. Il représente
ainsi la différence d’état avant et après la modification d’un ou plusieurs fichiers. Lorsqu’une
modification « n’est pas commit », c’est qu’elle n’est présente que localement sur votre ordinateur,
et donc que GitHub n’a aucune connaissance de cette modification. Voici les étapes afin de commits
vos modifications sur GitHub.</p>
<p>Premièrement, la commande <cite>git status</cite> vous permet de voir les modifications. Voici un exemple de
retour de cette commande, exemple tiré de quand j’écris la documentation :).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git status</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Changes not staged for commit:</span>
<span class="gp gp-VirtualEnv">(use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span>
<span class="gp gp-VirtualEnv">(use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span>
<span class="go">        modified:   source/glossary.rst</span>
<span class="go">        modified:   source/index.rst</span>
<span class="go">        modified:   source/ros/navigation.rst</span>

<span class="go">Untracked files:</span>
<span class="gp gp-VirtualEnv">(use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span>
<span class="go">        source/orga/index.rst</span>
<span class="go">        source/orga/wf_github.rst</span>

<span class="go">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span>
</pre></div>
</div>
<p>On peut voir la ligne <cite>Changes not staged for commit</cite>. Lorsqu’un fichier est « staged », c’est que
l’état actuel de modification du fichier a été enregistré localement et pourra ensuite être commit.
On peut aussi voir « Untracked files ». Ce sont des nouveaux fichiers qui eux-aussi, n’ont pas été
commit et dont GitHub n’a aucune connaissance car ils sont nouveaux.</p>
<p>Pour ajouter les changements que vous voulez commit, et rendre les fichiers « staged » il faut
utiliser <cite>git add votre_fichier</cite>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git add</span>
</pre></div>
</div>
<p>Vous pouvez ensuite commit vos modifications avec une petite explication de celles-ci avec la
commande <cite>git commit -m « Mon message de commit »</cite>. Vous trouverez juste en dessous des
recommandations par rapport aux commits.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git commit</span>
</pre></div>
</div>
</section>
<section id="recommandations">
<h3><a class="toc-backref" href="#id13" role="doc-backlink">Recommandations</a><a class="headerlink" href="#recommandations" title="Link to this heading"></a></h3>
<p>Nous essayons de garder nos commits « atomiques », cela signifie qu’un commit correspond à une
modification. Elle peut-être plus ou moins grosse et concernée un ou plusieurs fichiers. Il faut
simplement garder en tête que les commits servent à garder un historique de ce qui est fait : en
faisant des commits atomiques, on peut revenir en arrière simplement sur une fonctionnalité, une
modification, etc.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Par exemple, si un commit supprime du code et ajoute une autre fonctionnalité qui
n’a rien à voir, il sera difficile de revenir en arrière sur cette fonctionnalité sans affecter
le reste du code.</p>
</div>
<p>Pour ce qui est des messages de commit, il faut les garder courts mais consis (officiellement moins
de 50 caractères, mais il est possible de faire plus). Il est souvent intuitif de commencer le
message par un verbe et de décrire ensuite le(s) fichier(s) affecté(s) ou ce qui a été touché dans
le code. Le mieux est de combiner les deux, afin de comprendre rapidement ce qui a été fait dans un
commit. En effet, des messages de commit clairs permettent de comprendre rapidement ce qui a été
fait sans aller voir les détails du commit.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Par exemple, un message de commit qui modifie le fichier <cite>readme.md</cite> peut ressembler à « Update
readme », mais le mieux est aussi de mentionner ce qui a été mis à jour dans le readme. Un
message de commit plus complet serait « Update readme about build instructions ».</p>
</div>
<p>Il est possible de détailler un commit en y mettant plusieurs messages. Ils seront affichés de
manière différente sur GitHub. Le premier a pour but de décrire l’action globale et le deuxième peut
rajouter du détail.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git commit -m &quot;Update readme&quot; -m &quot;Explain how to build the package&quot;</span>
</pre></div>
</div>
</section>
<section id="squash">
<h3><a class="toc-backref" href="#id14" role="doc-backlink"><em>Squash</em></a><a class="headerlink" href="#squash" title="Link to this heading"></a></h3>
<p>« Squash » des commits est l’action de les rassembler en un seul. Elle est souvent utilisée lors d’un
merge.</p>
<p>Lorsqu’une branche est merge sans squash les commits, ils se retrouvent dans la branche cible comme
s’ils avaient été initialement faits dans celle-ci. Sur la figure juste en-dessous, les commits sont
représentés par des cercles et l’historique se lit de gauche à droite. Une branche est dérivée de la
branche nommée « main » et des commits sont faits dedans. Lorsque la branche est merge (dernier commit
bleu clair), les commits de la branche violette apparaissent dans la branche main (commits en
transparence).</p>
<figure class="align-center" id="id2">
<img alt="../_images/no_squash.png" src="../_images/no_squash.png" />
<figcaption>
<p><span class="caption-text">Merge sans squash</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Lorsqu’une branche est merge en squashant les commits, ils ne se retrouvent pas dans la branche
cible. Le seul commit présent est celui informant du merge. La figure ci-dessous fonctionne comme la
précédente, cependant, on peut voir qu’aucun autre commit venant de la branche violette n’est
présent dans la main, excepté celui indiquant le merge (dernier commit bleu clair).</p>
<figure class="align-center" id="id3">
<img alt="../_images/squash.png" src="../_images/squash.png" />
<figcaption>
<p><span class="caption-text">Merge avec squash</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Les merges de branch étant souvent fait sur l’interface de GitHub, c’est celle-ci qui permet de
choisir si les commits sont squash, ou non, lors d’un merge. De manière générale, il n’est pas
recommandé de squash les commits car l’historique des modifications est perdue et il est difficile
de revenir sur un changement précis.</p>
</section>
</section>
<section id="branches">
<h2><a class="toc-backref" href="#id15" role="doc-backlink">Branches</a><a class="headerlink" href="#branches" title="Link to this heading"></a></h2>
<p>Les branches permettent de travailler indépendamment, que ce soit à plusieurs ou même tout seul.
Elles permettent d’isoler des modifications du reste du code sur le repo, par exemple pour rajouter
une fonctionnalité ou même avoir une toute autre version du repo.</p>
<section id="id1">
<h3><a class="toc-backref" href="#id16" role="doc-backlink">Recommandations</a><a class="headerlink" href="#id1" title="Link to this heading"></a></h3>
<p>La branche créée par défaut par GitHub est nommée « main » (anciennement, « master »). C’est la branche
principale du repo, le but étant de la garder dans un état fonctionnel. Pour cela, il est recommandé
de travailler sur d’autres branches pour modifier du code et implémeter des nouveautés.</p>
<section id="notre-organisation">
<h4><a class="toc-backref" href="#id17" role="doc-backlink">Notre organisation</a><a class="headerlink" href="#notre-organisation" title="Link to this heading"></a></h4>
<p>Les branches pour modifier le repo peuvent directement hériter de la main. Nous tentons de respecter
une convention de nommage des branches afin de mieux comprendre leur rôle. Le nom de la branche
commence par un préfix puis par ce que la branche concerne. Les suffixes peuvent être les suivants
(liste non-exhaustive, et modifiable au bon vouloir de chacun, rien n’est obligé) :</p>
<ul class="simple">
<li><p>feature/… : pour rajouter une fonctionnalité au repo</p></li>
<li><p>fix/… : pour résoudre un problème / bug sur le repo</p></li>
<li><p>test/… : pour tester du code sur le repo</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Par exemple, pour rajouter une fonctionnalité de détection de couleurs à un repo de vision par
ordinateur, la branche pourrait se nommer « feature/color_detection ».</p>
</div>
<p>Une fois le travail sur la branche terminé, on réalise une pull request sur GitHub pour merge la
branche dans la main.</p>
<p>Sur l’image d’illustration suivante, les commits sont représentés par des cercles et la temporalité
se déroule de gauche à droite. Les commits de la branche main sont en bleur clair. Premièrement, une
branche dérivée de la main est créée et possède deux commits. Elle est ensuite merge dans la main
par un commit, les deux commits en transparence étant ceux de la branche qui sont présents sur la
main s’ils n’ont pas été squash. Une autre branche a ensuite été dérivée à partir du dernier commit
de la main.</p>
<figure class="align-center" id="id4">
<img alt="../_images/main_feature.png" src="../_images/main_feature.png" />
<figcaption>
<p><span class="caption-text">Workflow avec une unique branche main</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="organisation-plus-professionnelle">
<h4><a class="toc-backref" href="#id18" role="doc-backlink">Organisation plus professionnelle</a><a class="headerlink" href="#organisation-plus-professionnelle" title="Link to this heading"></a></h4>
<p>Une organisation plus professionnelle consiste à garder la main dans une version avec des
fonctionnalités et caractéristiques connues (par exemple, la version x d’un projet). Pour cela,
cette branche est très peu touchée et c’est une branche, souvent nommée « develop » (ou « dev »), sur
laquelle le travail est réalisé la majeure partie du temps. C’est donc de cette branche que partent
les branches pour rajouter des fonctionnalités, modifier le code, etc. Quand il est estimé que la
branche « develop » a atteint un avancement suffisant, elle est merge dans la brache « main ». Le projet
est donc dans une nouvelle version. Ainsi, les seuls commits présents sur la main sont les commits
de merge de la branche « develop ».</p>
<p>Si un problème assez important pour ne pas attendre une nouvelle version est détecté, il est courant
de directement créer une branche héritant de la main avec comme nom « hotfix/&lt;problème_à_régler&gt; » et
de la merge une fois le problème fixé.</p>
<p>De même que pour la première illustration, les commits sont représentés par des cercles et le temps
s’écoule de gauche à droite. La main est toujours représentée par du bleu clair et la branche
« develop » est introduite, en vert. On voit maintenant que la branche quelconque est dérivée de la
dev, possède quelques commits et est mergée dans la dev. Les commits en transparence sont ceux de la
branche quelconque, qui peuvent apparaître dans la dev s’ils ne sont pas squash. La dev est ensuite
merge dans la main, en squashant les commits afin de n’avoir qu’un seul commit, celui du merge (à
noter que ce n’est pas obligatoire de squash les commits, cela permet juste de garder la main
parfaitement propre). Le travail est ensuite continué sur la dev, avec une branche quelconque qui en
est dérivée.</p>
<figure class="align-center" id="id5">
<img alt="../_images/main_dev_feature.png" src="../_images/main_dev_feature.png" />
<figcaption>
<p><span class="caption-text">Workflow avec des branche main et dev</span><a class="headerlink" href="#id5" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="branche-en-retard">
<h4><a class="toc-backref" href="#id19" role="doc-backlink">Branche en retard</a><a class="headerlink" href="#branche-en-retard" title="Link to this heading"></a></h4>
<p>Il arrive parfois de travailler sur une branche et la branche dont elle hérite possède de nouveaux
commits dont on a besoin.</p>
<figure class="align-center" id="id6">
<img alt="../_images/feature_retard.png" src="../_images/feature_retard.png" />
<figcaption>
<p><span class="caption-text">Branche en retard sur la main</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Pour résoudre ce problème, il y a deux cas dfférents en fonction de l’état de la branche : est-elle
uniquement locale ou est-elle commit sur GitHub ?</p>
<p>Vous pouvez trouver plus d’informations sur ce problème et sur les méthodes pour le résoudre sur
cette <a class="reference external" href="https://www.atlassian.com/git/tutorials/merging-vs-rebasing">page</a>, dont les schémas ont
inspiré ceux de cette page ;).</p>
<p>Voici une explication résumée.</p>
<section id="branche-locale">
<h5>Branche locale<a class="headerlink" href="#branche-locale" title="Link to this heading"></a></h5>
<p>Si votre branche est uniquement locale, c’est-à-dire qu’elle n’est pas commit sur GitHub, il est
préférable d’utiliser la fonction <cite>rebase</cite> de git. Cette fonction redéfinit le commit d’origine
d’une branche.</p>
<figure class="align-center" id="id7">
<img alt="../_images/rebase.png" src="../_images/rebase.png" />
<figcaption>
<p><span class="caption-text">Branches après un rebase</span><a class="headerlink" href="#id7" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Premièrement, il faut se placer sur la branche locale :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git checkout ma_branche_locale</span>
</pre></div>
</div>
<p>Et secondement, il faut utiliser la fonctionnalité de <cite>rebase</cite> avec la branche qui a avancé (ici,
main) :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git rebase main</span>
</pre></div>
</div>
<p>Normalement, votre branche a maintenant comme commit d’origine le dernier commit de la main et vous
avez récupéré ses dernières modifications.</p>
</section>
<section id="branche-deja-commit">
<h5>Branche déjà commit<a class="headerlink" href="#branche-deja-commit" title="Link to this heading"></a></h5>
<p>Si votre branche est déjà commit sur GitHub, il est possible d’utiliser la fonctionnalité de
<cite>rebase</cite> mais ce n’est pas recommandé : l’entièreté de votre historique de commits sur cette branche
sera réecrit et des conflits peuvent apparaître. Il est donc recommandé de simplement merge la
branche en avance dans la branche  en retard pour récupérer ses commits.</p>
<figure class="align-center" id="id8">
<img alt="../_images/merge.png" src="../_images/merge.png" />
<figcaption>
<p><span class="caption-text">Branches après un merge</span><a class="headerlink" href="#id8" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Premièrement, n’oubliez pas de récupérer les derniers commits de la branche en avance (ici, main) :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git pull main</span>
</pre></div>
</div>
<p>Ensuite, il faut se placer dans votre branche :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git checkout ma_branche</span>
</pre></div>
</div>
<p>Dernièrement, il faut utiliser la fonction <cite>merge</cite> avec la branche en avance (ici, main) :</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">git merge main</span>
</pre></div>
</div>
<p>Cette méthode permet de récupérer les changements sur la branche en retard et ne place qu’un seul
commit dans votre branche, celui du merge.</p>
</section>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Pied de page">
        <a href="repos.html" class="btn btn-neutral float-left" title="Repos" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Précédent</a>
        <a href="../ros/index.html" class="btn btn-neutral float-right" title="ROS" accesskey="n" rel="next">Suivant <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Droits d'auteur 2023, Florent CHRETIEN, Mélanie LELAURE, Lucas SI LARBI, Antoine GROS.</p>
  </div>

  Compilé avec <a href="https://www.sphinx-doc.org/">Sphinx</a> en utilisant un
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">thème</a>
    fourni par <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>